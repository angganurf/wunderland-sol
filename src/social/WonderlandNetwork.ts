/**
 * @fileoverview WonderlandNetwork — main orchestrator for the agents-only social platform.
 *
 * Coordinates all social components:
 * - StimulusRouter for event distribution
 * - NewsroomAgency instances for each citizen
 * - LevelingEngine for XP/progression
 * - SocialPostTool for feed persistence
 *
 * @module wunderland/social/WonderlandNetwork
 */

import { StimulusRouter } from './StimulusRouter.js';
import { NewsroomAgency } from './NewsroomAgency.js';
import { LevelingEngine } from './LevelingEngine.js';
import { MoodEngine } from './MoodEngine.js';
import { EnclaveRegistry } from './EnclaveRegistry.js';
import { PostDecisionEngine } from './PostDecisionEngine.js';
import { BrowsingEngine } from './BrowsingEngine.js';
import { ContentSentimentAnalyzer } from './ContentSentimentAnalyzer.js';
import { LLMSentimentAnalyzer } from './LLMSentimentAnalyzer.js';
import { NewsFeedIngester } from './NewsFeedIngester.js';
import { extractStimulusText } from './DynamicVoiceProfile.js';
import type { IMoodPersistenceAdapter } from './MoodPersistence.js';
import type { IEnclavePersistenceAdapter } from './EnclavePersistence.js';
import type { IBrowsingPersistenceAdapter } from './BrowsingPersistence.js';
import type { LLMInvokeCallback, DynamicVoiceSnapshot } from './NewsroomAgency.js';
import type { ITool } from '@framers/agentos';
import type { PADState, MoodDelta } from './MoodEngine.js';
import type { VoiceArchetype } from './DynamicVoiceProfile.js';
import type {
  WonderlandNetworkConfig,
  CitizenProfile,
  WonderlandPost,
  StimulusEvent,
  Tip,
  ApprovalQueueEntry,
  EngagementActionType,
  NewsroomConfig,
  CitizenLevel,
  EnclaveConfig,
  BrowsingSessionRecord,
} from './types.js';
import { CitizenLevel as Level, XP_REWARDS } from './types.js';

/**
 * Callback for post storage.
 */
export type PostStoreCallback = (post: WonderlandPost) => Promise<void>;

type MoodTelemetrySource = 'stimulus' | 'engagement' | 'emoji' | 'system';

export interface AgentBehaviorTelemetry {
  seedId: string;
  mood: {
    updates: number;
    cumulativeDrift: number;
    averageDrift: number;
    maxDrift: number;
    lastDrift: number;
    lastTrigger?: string;
    lastSource?: MoodTelemetrySource;
    lastUpdatedAt?: string;
    currentState?: PADState;
  };
  voice: {
    updates: number;
    currentArchetype?: VoiceArchetype;
    archetypeSwitches: number;
    lastStimulusType?: StimulusEvent['payload']['type'];
    lastStimulusPriority?: StimulusEvent['priority'];
    lastUrgency?: number;
    lastSentiment?: number;
    lastControversy?: number;
    lastUpdatedAt?: string;
  };
  engagement: {
    received: {
      likes: number;
      boosts: number;
      replies: number;
      views: number;
      emojiReactions: number;
    };
    moodDelta: {
      valence: number;
      arousal: number;
      dominance: number;
    };
    lastUpdatedAt?: string;
  };
}

export type WonderlandTelemetryEvent =
  | {
      type: 'mood_drift';
      seedId: string;
      timestamp: string;
      source: MoodTelemetrySource;
      trigger: string;
      drift: number;
      state: PADState;
    }
  | {
      type: 'voice_profile';
      seedId: string;
      timestamp: string;
      archetype: VoiceArchetype;
      switchedArchetype: boolean;
      previousArchetype?: VoiceArchetype;
      stimulusType: StimulusEvent['payload']['type'];
      stimulusPriority: StimulusEvent['priority'];
      urgency: number;
      sentiment: number;
      controversy: number;
    }
  | {
      type: 'engagement_impact';
      seedId: string;
      timestamp: string;
      action: 'like' | 'boost' | 'reply' | 'view' | 'emoji_reaction';
      delta: {
        valence: number;
        arousal: number;
        dominance: number;
      };
    };

export type TelemetryUpdateCallback = (
  event: WonderlandTelemetryEvent
) => void | Promise<void>;

interface InertiaVector {
  valence: number;
  arousal: number;
  dominance: number;
  updatedAtMs: number;
}

interface AgentMoodInertia {
  global: InertiaVector;
  threads: Map<string, InertiaVector>;
}

/**
 * WonderlandNetwork is the top-level orchestrator.
 *
 * @example
 * ```typescript
 * const network = new WonderlandNetwork({
 *   networkId: 'wonderland-main',
 *   worldFeedSources: [
 *     { sourceId: 'reuters', name: 'Reuters', type: 'rss', categories: ['world', 'tech'], isActive: true }
 *   ],
 *   globalRateLimits: { maxPostsPerHourPerAgent: 5, maxTipsPerHourPerUser: 20 },
 *   defaultApprovalTimeoutMs: 300000,
 *   quarantineNewCitizens: true,
 *   quarantineDurationMs: 86400000,
 * });
 *
 * // Register a citizen
 * const citizen = await network.registerCitizen({
 *   seedConfig: { ... },
 *   ownerId: 'user-123',
 *   worldFeedTopics: ['technology'],
 *   acceptTips: true,
 *   postingCadence: { type: 'interval', value: 3600000 },
 *   maxPostsPerHour: 3,
 *   approvalTimeoutMs: 300000,
 *   requireApproval: true,
 * });
 *
 * // Start the network
 * await network.start();
 * ```
 */
export class WonderlandNetwork {
  private config: WonderlandNetworkConfig;
  private stimulusRouter: StimulusRouter;
  private levelingEngine: LevelingEngine;

  /** Active newsroom agencies (seedId → NewsroomAgency) */
  private newsrooms: Map<string, NewsroomAgency> = new Map();

  /** Citizen profiles (seedId → CitizenProfile) */
  private citizens: Map<string, CitizenProfile> = new Map();

  /** Published posts (postId → WonderlandPost) */
  private posts: Map<string, WonderlandPost> = new Map();

  /** External post storage callback */
  private postStoreCallback?: PostStoreCallback;

  /** Default LLM callback applied to newly registered citizens */
  private defaultLLMCallback?: LLMInvokeCallback;

  /** Default toolset applied to newly registered citizens */
  private defaultTools: ITool[] = [];

  /** Whether the network is running */
  private running = false;

  // ── Enclave System (optional, initialized via initializeEnclaveSystem) ──

  /** PAD mood engine for personality-driven mood tracking */
  private moodEngine?: MoodEngine;

  /** Enclave catalog and membership registry */
  private enclaveRegistry?: EnclaveRegistry;

  /** Personality-driven post action decision engine */
  private postDecisionEngine?: PostDecisionEngine;

  /** Browsing session orchestrator */
  private browsingEngine?: BrowsingEngine;

  /** Lightweight keyword-based content sentiment analyzer */
  private contentSentimentAnalyzer?: ContentSentimentAnalyzer;

  /** Optional LLM-backed mood impact analyzer for richer stimulus reactions */
  private llmSentimentAnalyzer?: LLMSentimentAnalyzer;

  /** Per-agent telemetry for mood drift, voice shifts, and engagement impact. */
  private behaviorTelemetry: Map<string, AgentBehaviorTelemetry> = new Map();

  /** Subscribers for telemetry update events. */
  private telemetryCallbacks: TelemetryUpdateCallback[] = [];

  /** Per-agent momentum buffers used for cross-thread mood inertia. */
  private moodInertiaState: Map<string, AgentMoodInertia> = new Map();

  /** External news feed ingestion framework */
  private newsFeedIngester?: NewsFeedIngester;

  /** Whether the enclave subsystem has been initialized */
  private enclaveSystemInitialized = false;

  /** Browsing session log (seedId -> most recent session record) */
  private browsingSessionLog: Map<string, BrowsingSessionRecord> = new Map();

  // ── Persistence Adapters (optional, set before initializeEnclaveSystem) ──

  private moodPersistenceAdapter?: IMoodPersistenceAdapter;
  private enclavePersistenceAdapter?: IEnclavePersistenceAdapter;
  private browsingPersistenceAdapter?: IBrowsingPersistenceAdapter;

  constructor(config: WonderlandNetworkConfig) {
    this.config = config;
    this.stimulusRouter = new StimulusRouter();
    this.levelingEngine = new LevelingEngine();
    // Note: SignedOutputVerifier will be used for manifest verification in future

    // Register world feed sources
    for (const source of config.worldFeedSources) {
      this.stimulusRouter.registerWorldFeedSource(source);
    }
  }

  /**
   * Start the network (begin processing stimuli).
   *
   * If the subreddit system is initialized, also registers a network-level
   * cron_tick subscriber for the 'browse' schedule.
   */
  async start(): Promise<void> {
    this.running = true;

    // Register a network-level subscriber for browse cron ticks
    if (this.enclaveSystemInitialized) {
      this.stimulusRouter.subscribe(
        '__network_browse__',
        async (event) => {
          if (!this.running) return;
          if (
            event.type === 'cron_tick' &&
            event.payload.type === 'cron_tick' &&
            event.payload.scheduleName === 'browse'
          ) {
            await this.handleBrowseCronTick();
          }
        },
        {
          typeFilter: ['cron_tick'],
        },
      );
    }

    console.log(`[WonderlandNetwork] Network '${this.config.networkId}' started. Citizens: ${this.citizens.size}`);
  }

  /**
   * Stop the network.
   */
  async stop(): Promise<void> {
    this.running = false;

    // Unsubscribe the network-level browse cron listener
    if (this.enclaveSystemInitialized) {
      this.stimulusRouter.unsubscribe('__network_browse__');
    }

    console.log(`[WonderlandNetwork] Network '${this.config.networkId}' stopped.`);
  }

  /**
   * Register a citizen and create their Newsroom agency.
   */
  async registerCitizen(newsroomConfig: NewsroomConfig): Promise<CitizenProfile> {
    const seedId = newsroomConfig.seedConfig.seedId;

    if (this.citizens.has(seedId)) {
      throw new Error(`Citizen '${seedId}' is already registered.`);
    }

    // Create citizen profile
    const citizen: CitizenProfile = {
      seedId,
      ownerId: newsroomConfig.ownerId,
      displayName: newsroomConfig.seedConfig.name,
      bio: newsroomConfig.seedConfig.description,
      personality: newsroomConfig.seedConfig.hexacoTraits,
      level: Level.NEWCOMER,
      xp: 0,
      totalPosts: 0,
      joinedAt: new Date().toISOString(),
      isActive: true,
      subscribedTopics: newsroomConfig.worldFeedTopics,
      postRateLimit: newsroomConfig.maxPostsPerHour,
    };

    // Create Newsroom agency
    const newsroom = new NewsroomAgency(newsroomConfig);
    newsroom.setMoodSnapshotProvider(() => {
      const engine = this.moodEngine;
      if (!engine) return {};
      return { label: engine.getMoodLabel(seedId), state: engine.getState(seedId) };
    });

    if (this.defaultLLMCallback) {
      newsroom.setLLMCallback(this.defaultLLMCallback);
    }
    if (this.defaultTools.length > 0) {
      newsroom.registerTools(this.defaultTools);
    }

    // Wire up callbacks
    newsroom.onPublish(async (post) => {
      await this.handlePostPublished(post);
    });
    newsroom.onDynamicVoiceProfile((snapshot) => {
      this.recordVoiceTelemetry(snapshot);
    });

    // Subscribe to stimuli
    this.stimulusRouter.subscribe(
      seedId,
      async (event) => {
        if (!this.running) return;
        await this.applyStimulusMoodImpact(seedId, event);
        await newsroom.processStimulus(event);
      },
      {
        typeFilter: ['world_feed', 'tip', 'agent_reply', 'cron_tick', 'internal_thought', 'channel_message', 'agent_dm'],
        categoryFilter: newsroomConfig.worldFeedTopics,
      },
    );

    this.citizens.set(seedId, citizen);
    this.newsrooms.set(seedId, newsroom);
    this.ensureTelemetry(seedId);
    this.ensureInertiaState(seedId);

    // If enclave system is active, initialize mood and subscribe to matching enclaves
    if (this.enclaveSystemInitialized && this.moodEngine) {
      this.moodEngine.initializeAgent(seedId, newsroomConfig.seedConfig.hexacoTraits);
      this.autoSubscribeCitizenToEnclaves(seedId, newsroomConfig.worldFeedTopics);
    }

    console.log(`[WonderlandNetwork] Registered citizen '${seedId}' (${citizen.displayName})`);
    return citizen;
  }

  /**
   * Unregister a citizen.
   */
  async unregisterCitizen(seedId: string): Promise<void> {
    this.stimulusRouter.unsubscribe(seedId);
    this.newsrooms.delete(seedId);
    this.moodInertiaState.delete(seedId);
    const citizen = this.citizens.get(seedId);
    if (citizen) {
      citizen.isActive = false;
    }
  }

  /**
   * Submit a tip (paid stimulus from a human).
   */
  async submitTip(tip: Tip): Promise<{ eventId: string }> {
    const event = await this.stimulusRouter.ingestTip(tip);
    return { eventId: event.eventId };
  }

  /**
   * Record an engagement action on a post.
   */
  async recordEngagement(
    postId: string,
    _actorSeedId: string,
    actionType: EngagementActionType,
  ): Promise<void> {
    const post = this.posts.get(postId);
    if (!post) return;

    // Update post engagement
    switch (actionType) {
      case 'like': post.engagement.likes++; break;
      case 'boost': post.engagement.boosts++; break;
      case 'reply': post.engagement.replies++; break;
      case 'view': post.engagement.views++; break;
    }

    // Award XP to the post author
    const author = this.citizens.get(post.seedId);
    if (author) {
      const xpKey = `${actionType}_received` as keyof typeof XP_REWARDS;
      if (xpKey in XP_REWARDS) {
        this.levelingEngine.awardXP(author, xpKey);
      }
    }

    // Apply mood impact + telemetry to the post author (ignore self-engagement).
    if (post.seedId !== _actorSeedId) {
      if (
        actionType === 'like' ||
        actionType === 'boost' ||
        actionType === 'reply' ||
        actionType === 'view'
      ) {
        this.recordEngagementImpact(post.seedId, actionType);
      }

      let delta: MoodDelta | undefined;
      let deltaAction: 'like' | 'boost' | 'reply' | undefined;
      switch (actionType) {
        case 'like':
          delta = { valence: 0.06, arousal: 0.02, dominance: 0.02, trigger: 'received_like' };
          deltaAction = 'like';
          break;
        case 'boost':
          delta = { valence: 0.08, arousal: 0.03, dominance: 0.04, trigger: 'received_boost' };
          deltaAction = 'boost';
          break;
        case 'reply':
          delta = { valence: 0.03, arousal: 0.06, dominance: 0.03, trigger: 'received_reply' };
          deltaAction = 'reply';
          break;
        case 'view':
          this.emitTelemetry({
            type: 'engagement_impact',
            seedId: post.seedId,
            timestamp: new Date().toISOString(),
            action: 'view',
            delta: { valence: 0, arousal: 0, dominance: 0 },
          });
          break;
      }

      if (delta && deltaAction) {
        this.recordEngagementMoodDelta(post.seedId, delta, deltaAction);
        this.applyMoodDeltaWithTelemetry(post.seedId, delta, 'engagement');
      }
    }
  }

  /**
   * Approve a pending post via its queue ID.
   */
  async approvePost(seedId: string, queueId: string): Promise<WonderlandPost | null> {
    const newsroom = this.newsrooms.get(seedId);
    if (!newsroom) return null;

    const post = await newsroom.approvePost(queueId);
    if (post) {
      const citizen = this.citizens.get(seedId);
      if (citizen) {
        post.agentLevelAtPost = citizen.level;
      }
      await this.handlePostPublished(post);
    }
    return post;
  }

  /**
   * Reject a pending post.
   */
  rejectPost(seedId: string, queueId: string, reason?: string): void {
    const newsroom = this.newsrooms.get(seedId);
    if (!newsroom) return;
    newsroom.rejectPost(queueId, reason);
  }

  /**
   * Get the public feed (most recent posts).
   */
  getFeed(options?: {
    limit?: number;
    cursor?: string;
    seedId?: string;
    minLevel?: CitizenLevel;
  }): WonderlandPost[] {
    let feed = [...this.posts.values()]
      .filter((p) => p.status === 'published')
      .sort((a, b) => (b.publishedAt || '').localeCompare(a.publishedAt || ''));

    if (options?.seedId) {
      feed = feed.filter((p) => p.seedId === options.seedId);
    }

    if (options?.minLevel) {
      feed = feed.filter((p) => p.agentLevelAtPost >= options.minLevel!);
    }

    const limit = options?.limit ?? 50;
    return feed.slice(0, limit);
  }

  /**
   * Get a citizen profile.
   */
  getCitizen(seedId: string): CitizenProfile | undefined {
    return this.citizens.get(seedId);
  }

  /**
   * Get all active citizens.
   */
  listCitizens(): CitizenProfile[] {
    return [...this.citizens.values()].filter((c) => c.isActive);
  }

  /**
   * Get a post by ID.
   */
  getPost(postId: string): WonderlandPost | undefined {
    return this.posts.get(postId);
  }

  /**
   * Get the StimulusRouter (for external integrations).
   */
  getStimulusRouter(): StimulusRouter {
    return this.stimulusRouter;
  }

  /**
   * Get the LevelingEngine.
   */
  getLevelingEngine(): LevelingEngine {
    return this.levelingEngine;
  }

  /**
   * Get the approval queue for a specific owner.
   */
  getApprovalQueue(ownerId: string): ApprovalQueueEntry[] {
    const entries: ApprovalQueueEntry[] = [];
    for (const newsroom of this.newsrooms.values()) {
      for (const entry of newsroom.getPendingApprovals()) {
        if (entry.ownerId === ownerId) {
          entries.push(entry);
        }
      }
    }
    return entries;
  }

  /**
   * Set external storage callback for posts.
   */
  setPostStoreCallback(callback: PostStoreCallback): void {
    this.postStoreCallback = callback;
  }

  /** Set persistence adapter for mood state. */
  setMoodPersistenceAdapter(adapter: IMoodPersistenceAdapter): void {
    this.moodPersistenceAdapter = adapter;
    if (this.moodEngine) {
      this.moodEngine.setPersistenceAdapter(adapter);
    }
  }

  /** Set persistence adapter for enclave state. */
  setEnclavePersistenceAdapter(adapter: IEnclavePersistenceAdapter): void {
    this.enclavePersistenceAdapter = adapter;
    if (this.enclaveRegistry) {
      this.enclaveRegistry.setPersistenceAdapter(adapter);
    }
  }

  /** Set persistence adapter for browsing sessions. */
  setBrowsingPersistenceAdapter(adapter: IBrowsingPersistenceAdapter): void {
    this.browsingPersistenceAdapter = adapter;
  }

  /**
   * Subscribe to telemetry updates (mood drift, voice profile, engagement impact).
   */
  onTelemetryUpdate(callback: TelemetryUpdateCallback): void {
    this.telemetryCallbacks.push(callback);
  }

  /**
   * Get telemetry for a specific agent.
   */
  getAgentBehaviorTelemetry(seedId: string): AgentBehaviorTelemetry | undefined {
    const telemetry = this.behaviorTelemetry.get(seedId);
    return telemetry ? this.cloneTelemetry(telemetry) : undefined;
  }

  /**
   * Get telemetry for all tracked agents.
   */
  listBehaviorTelemetry(): AgentBehaviorTelemetry[] {
    return [...this.behaviorTelemetry.values()].map((entry) => this.cloneTelemetry(entry));
  }

  /**
   * Set an optional LLM sentiment analyzer used to convert incoming stimuli
   * into PAD mood deltas before newsroom processing.
   */
  setLLMSentimentAnalyzer(analyzer: LLMSentimentAnalyzer | undefined): void {
    this.llmSentimentAnalyzer = analyzer;
  }

  /**
   * Set LLM callback for ALL registered newsroom agencies.
   * This enables production mode (real LLM calls) for the Writer phase.
   */
  setLLMCallbackForAll(callback: LLMInvokeCallback): void {
    this.defaultLLMCallback = callback;
    for (const newsroom of this.newsrooms.values()) {
      newsroom.setLLMCallback(callback);
    }
  }

  /**
   * Set an LLM callback for a specific citizen's newsroom agency.
   */
  setLLMCallbackForCitizen(seedId: string, callback: LLMInvokeCallback): void {
    const newsroom = this.newsrooms.get(seedId);
    if (!newsroom) throw new Error(`Citizen '${seedId}' is not registered.`);
    newsroom.setLLMCallback(callback);
  }

  /**
   * Register tools for all citizens (applies immediately and becomes the default toolset).
   */
  registerToolsForAll(tools: ITool[]): void {
    this.defaultTools = this.mergeTools(this.defaultTools, tools);
    for (const newsroom of this.newsrooms.values()) {
      newsroom.registerTools(tools);
    }
  }

  /**
   * Register tools for a specific citizen's newsroom agency.
   */
  registerToolsForCitizen(seedId: string, tools: ITool[]): void {
    const newsroom = this.newsrooms.get(seedId);
    if (!newsroom) throw new Error(`Citizen '${seedId}' is not registered.`);
    newsroom.registerTools(tools);
  }

  private mergeTools(existing: ITool[], next: ITool[]): ITool[] {
    const map = new Map<string, ITool>();
    for (const tool of existing) map.set(tool.name, tool);
    for (const tool of next) map.set(tool.name, tool);
    return [...map.values()];
  }

  /**
   * Apply a mood update from the incoming stimulus before newsroom processing.
   * This makes news/replies/emotional inputs affect downstream writing style.
   */
  private async applyStimulusMoodImpact(seedId: string, event: StimulusEvent): Promise<void> {
    const engine = this.moodEngine;
    if (!engine) return;

    const currentMood = engine.getState(seedId);
    if (!currentMood) return;

    const stimulusText = extractStimulusText(event).trim();
    const impactWeight = this.getStimulusImpactWeight(event);

    let delta:
      | {
          valence: number;
          arousal: number;
          dominance: number;
          trigger: string;
        }
      | undefined;

    if (this.llmSentimentAnalyzer && stimulusText) {
      try {
        delta = await this.llmSentimentAnalyzer.analyzeMoodImpact(stimulusText, currentMood);
      } catch {
        delta = undefined;
      }
    }

    if (!delta) {
      delta = this.buildFallbackStimulusDelta(seedId, event, stimulusText);
    }

    const scaledDelta: MoodDelta = {
      valence: this.clampSigned(delta.valence * impactWeight, -0.35, 0.35),
      arousal: this.clampSigned(delta.arousal * impactWeight, -0.35, 0.35),
      dominance: this.clampSigned(delta.dominance * impactWeight, -0.35, 0.35),
      trigger: `stimulus_${event.payload.type}:${delta.trigger}`,
    };

    const inertiaAdjusted = this.applyCrossThreadMoodInertia(seedId, event, scaledDelta);
    const magnitude =
      Math.abs(inertiaAdjusted.valence) +
      Math.abs(inertiaAdjusted.arousal) +
      Math.abs(inertiaAdjusted.dominance);

    if (magnitude < 0.01) return;
    this.applyMoodDeltaWithTelemetry(seedId, inertiaAdjusted, 'stimulus');
  }

  private buildFallbackStimulusDelta(
    seedId: string,
    event: StimulusEvent,
    stimulusText: string,
  ): { valence: number; arousal: number; dominance: number; trigger: string } {
    const citizen = this.citizens.get(seedId);
    const tags = citizen?.subscribedTopics ?? [];
    const analysis =
      stimulusText && this.contentSentimentAnalyzer
        ? this.contentSentimentAnalyzer.analyze(stimulusText, tags)
        : undefined;

    const sentiment = analysis?.sentiment ?? 0;
    const controversy = analysis?.controversy ?? 0;

    let valence = sentiment * 0.16;
    let arousal = Math.abs(sentiment) * 0.08 + controversy * 0.10;
    let dominance = 0;

    switch (event.priority) {
      case 'breaking':
        arousal += 0.14;
        dominance += 0.03;
        break;
      case 'high':
        arousal += 0.08;
        break;
      case 'normal':
        arousal += 0.03;
        break;
      case 'low':
      default:
        arousal -= 0.02;
        break;
    }

    switch (event.payload.type) {
      case 'tip':
        arousal += 0.06;
        valence += 0.02;
        break;
      case 'agent_reply':
      case 'agent_dm':
      case 'channel_message':
        arousal += 0.05;
        dominance += 0.05;
        break;
      case 'world_feed':
      case 'internal_thought':
        dominance += 0.02;
        break;
      case 'cron_tick':
      default:
        break;
    }

    return {
      valence: this.clampSigned(valence, -0.3, 0.3),
      arousal: this.clampSigned(arousal, -0.3, 0.3),
      dominance: this.clampSigned(dominance, -0.3, 0.3),
      trigger: analysis ? 'keyword_sentiment' : 'priority_heuristic',
    };
  }

  private getStimulusImpactWeight(event: StimulusEvent): number {
    let byType = 0.6;
    switch (event.payload.type) {
      case 'tip':
        byType = 0.9;
        break;
      case 'agent_reply':
        byType = 0.85;
        break;
      case 'channel_message':
      case 'agent_dm':
        byType = 0.95;
        break;
      case 'world_feed':
        byType = 0.7;
        break;
      case 'internal_thought':
        byType = 0.65;
        break;
      case 'cron_tick':
      default:
        byType = 0.25;
        break;
    }

    let byPriority = 1;
    switch (event.priority) {
      case 'breaking':
        byPriority = 1.3;
        break;
      case 'high':
        byPriority = 1.15;
        break;
      case 'normal':
        byPriority = 1;
        break;
      case 'low':
      default:
        byPriority = 0.7;
        break;
    }

    return this.clamp01(byType * byPriority);
  }

  private ensureTelemetry(seedId: string): AgentBehaviorTelemetry {
    let telemetry = this.behaviorTelemetry.get(seedId);
    if (telemetry) return telemetry;

    telemetry = {
      seedId,
      mood: {
        updates: 0,
        cumulativeDrift: 0,
        averageDrift: 0,
        maxDrift: 0,
        lastDrift: 0,
      },
      voice: {
        updates: 0,
        archetypeSwitches: 0,
      },
      engagement: {
        received: {
          likes: 0,
          boosts: 0,
          replies: 0,
          views: 0,
          emojiReactions: 0,
        },
        moodDelta: {
          valence: 0,
          arousal: 0,
          dominance: 0,
        },
      },
    };
    this.behaviorTelemetry.set(seedId, telemetry);
    return telemetry;
  }

  private cloneTelemetry(entry: AgentBehaviorTelemetry): AgentBehaviorTelemetry {
    return {
      seedId: entry.seedId,
      mood: {
        updates: entry.mood.updates,
        cumulativeDrift: entry.mood.cumulativeDrift,
        averageDrift: entry.mood.averageDrift,
        maxDrift: entry.mood.maxDrift,
        lastDrift: entry.mood.lastDrift,
        lastTrigger: entry.mood.lastTrigger,
        lastSource: entry.mood.lastSource,
        lastUpdatedAt: entry.mood.lastUpdatedAt,
        currentState: entry.mood.currentState ? { ...entry.mood.currentState } : undefined,
      },
      voice: {
        updates: entry.voice.updates,
        currentArchetype: entry.voice.currentArchetype,
        archetypeSwitches: entry.voice.archetypeSwitches,
        lastStimulusType: entry.voice.lastStimulusType,
        lastStimulusPriority: entry.voice.lastStimulusPriority,
        lastUrgency: entry.voice.lastUrgency,
        lastSentiment: entry.voice.lastSentiment,
        lastControversy: entry.voice.lastControversy,
        lastUpdatedAt: entry.voice.lastUpdatedAt,
      },
      engagement: {
        received: { ...entry.engagement.received },
        moodDelta: { ...entry.engagement.moodDelta },
        lastUpdatedAt: entry.engagement.lastUpdatedAt,
      },
    };
  }

  private emitTelemetry(event: WonderlandTelemetryEvent): void {
    for (const cb of this.telemetryCallbacks) {
      Promise.resolve(cb(event)).catch((err) => {
        console.error('[WonderlandNetwork] Telemetry callback error:', err);
      });
    }
  }

  private applyMoodDeltaWithTelemetry(
    seedId: string,
    delta: MoodDelta,
    source: MoodTelemetrySource,
  ): void {
    if (!this.moodEngine) return;
    const before = this.moodEngine.getState(seedId);
    if (!before) return;

    this.moodEngine.applyDelta(seedId, delta);
    const after = this.moodEngine.getState(seedId);
    if (!after) return;

    const drift = this.computePadDistance(before, after);
    const telemetry = this.ensureTelemetry(seedId);
    telemetry.mood.updates += 1;
    telemetry.mood.cumulativeDrift += drift;
    telemetry.mood.averageDrift =
      telemetry.mood.updates > 0
        ? telemetry.mood.cumulativeDrift / telemetry.mood.updates
        : 0;
    telemetry.mood.maxDrift = Math.max(telemetry.mood.maxDrift, drift);
    telemetry.mood.lastDrift = drift;
    telemetry.mood.lastTrigger = delta.trigger;
    telemetry.mood.lastSource = source;
    telemetry.mood.lastUpdatedAt = new Date().toISOString();
    telemetry.mood.currentState = { ...after };

    this.emitTelemetry({
      type: 'mood_drift',
      seedId,
      timestamp: telemetry.mood.lastUpdatedAt,
      source,
      trigger: delta.trigger,
      drift,
      state: { ...after },
    });
  }

  private computePadDistance(a: PADState, b: PADState): number {
    const dv = b.valence - a.valence;
    const da = b.arousal - a.arousal;
    const dd = b.dominance - a.dominance;
    return Math.sqrt(dv * dv + da * da + dd * dd);
  }

  private recordVoiceTelemetry(snapshot: DynamicVoiceSnapshot): void {
    const telemetry = this.ensureTelemetry(snapshot.seedId);
    telemetry.voice.updates += 1;
    if (snapshot.switchedArchetype) {
      telemetry.voice.archetypeSwitches += 1;
    }
    telemetry.voice.currentArchetype = snapshot.profile.archetype;
    telemetry.voice.lastStimulusType = snapshot.stimulusType;
    telemetry.voice.lastStimulusPriority = snapshot.stimulusPriority;
    telemetry.voice.lastUrgency = snapshot.profile.urgency;
    telemetry.voice.lastSentiment = snapshot.profile.sentiment;
    telemetry.voice.lastControversy = snapshot.profile.controversy;
    telemetry.voice.lastUpdatedAt = snapshot.timestamp;

    this.emitTelemetry({
      type: 'voice_profile',
      seedId: snapshot.seedId,
      timestamp: snapshot.timestamp,
      archetype: snapshot.profile.archetype,
      switchedArchetype: snapshot.switchedArchetype,
      previousArchetype: snapshot.previousArchetype,
      stimulusType: snapshot.stimulusType,
      stimulusPriority: snapshot.stimulusPriority,
      urgency: snapshot.profile.urgency,
      sentiment: snapshot.profile.sentiment,
      controversy: snapshot.profile.controversy,
    });
  }

  private recordEngagementImpact(
    seedId: string,
    action: 'like' | 'boost' | 'reply' | 'view' | 'emoji_reaction',
  ): void {
    const telemetry = this.ensureTelemetry(seedId);
    switch (action) {
      case 'like':
        telemetry.engagement.received.likes += 1;
        break;
      case 'boost':
        telemetry.engagement.received.boosts += 1;
        break;
      case 'reply':
        telemetry.engagement.received.replies += 1;
        break;
      case 'view':
        telemetry.engagement.received.views += 1;
        break;
      case 'emoji_reaction':
        telemetry.engagement.received.emojiReactions += 1;
        break;
    }
    telemetry.engagement.lastUpdatedAt = new Date().toISOString();
  }

  private recordEngagementMoodDelta(
    seedId: string,
    delta: Pick<MoodDelta, 'valence' | 'arousal' | 'dominance'>,
    action: 'like' | 'boost' | 'reply' | 'view' | 'emoji_reaction',
  ): void {
    const telemetry = this.ensureTelemetry(seedId);
    telemetry.engagement.moodDelta.valence = this.clampSigned(
      telemetry.engagement.moodDelta.valence + delta.valence,
      -5,
      5,
    );
    telemetry.engagement.moodDelta.arousal = this.clampSigned(
      telemetry.engagement.moodDelta.arousal + delta.arousal,
      -5,
      5,
    );
    telemetry.engagement.moodDelta.dominance = this.clampSigned(
      telemetry.engagement.moodDelta.dominance + delta.dominance,
      -5,
      5,
    );
    telemetry.engagement.lastUpdatedAt = new Date().toISOString();

    this.emitTelemetry({
      type: 'engagement_impact',
      seedId,
      timestamp: telemetry.engagement.lastUpdatedAt,
      action,
      delta: {
        valence: delta.valence,
        arousal: delta.arousal,
        dominance: delta.dominance,
      },
    });
  }

  private ensureInertiaState(seedId: string): AgentMoodInertia {
    let state = this.moodInertiaState.get(seedId);
    if (state) return state;

    const now = Date.now();
    state = {
      global: { valence: 0, arousal: 0, dominance: 0, updatedAtMs: now },
      threads: new Map<string, InertiaVector>(),
    };
    this.moodInertiaState.set(seedId, state);
    return state;
  }

  private applyCrossThreadMoodInertia(
    seedId: string,
    event: StimulusEvent,
    delta: MoodDelta,
  ): MoodDelta {
    const state = this.ensureInertiaState(seedId);
    const now = Date.now();
    const decayedGlobal = this.decayInertiaVector(state.global, now, 18 * 60_000);
    const threadKey = this.getStimulusThreadKey(event);
    const decayedThread = threadKey
      ? this.decayInertiaVector(state.threads.get(threadKey), now, 7 * 60_000)
      : { valence: 0, arousal: 0, dominance: 0, updatedAtMs: now };

    const blended: MoodDelta = {
      valence: this.clampSigned(delta.valence * 0.72 + decayedThread.valence * 0.18 + decayedGlobal.valence * 0.10, -0.35, 0.35),
      arousal: this.clampSigned(delta.arousal * 0.72 + decayedThread.arousal * 0.18 + decayedGlobal.arousal * 0.10, -0.35, 0.35),
      dominance: this.clampSigned(delta.dominance * 0.72 + decayedThread.dominance * 0.18 + decayedGlobal.dominance * 0.10, -0.35, 0.35),
      trigger: `${delta.trigger}:inertia`,
    };

    state.global = {
      valence: this.clampSigned(decayedGlobal.valence * 0.78 + blended.valence * 0.22, -0.35, 0.35),
      arousal: this.clampSigned(decayedGlobal.arousal * 0.78 + blended.arousal * 0.22, -0.35, 0.35),
      dominance: this.clampSigned(decayedGlobal.dominance * 0.78 + blended.dominance * 0.22, -0.35, 0.35),
      updatedAtMs: now,
    };

    if (threadKey) {
      state.threads.set(threadKey, {
        valence: this.clampSigned(decayedThread.valence * 0.6 + blended.valence * 0.4, -0.35, 0.35),
        arousal: this.clampSigned(decayedThread.arousal * 0.6 + blended.arousal * 0.4, -0.35, 0.35),
        dominance: this.clampSigned(decayedThread.dominance * 0.6 + blended.dominance * 0.4, -0.35, 0.35),
        updatedAtMs: now,
      });

      if (state.threads.size > 48) {
        const entries = [...state.threads.entries()].sort((a, b) => a[1].updatedAtMs - b[1].updatedAtMs);
        for (let i = 0; i < entries.length - 48; i++) {
          state.threads.delete(entries[i]![0]);
        }
      }
    }

    return blended;
  }

  private decayInertiaVector(
    vector: InertiaVector | undefined,
    nowMs: number,
    halfLifeMs: number,
  ): InertiaVector {
    if (!vector) {
      return { valence: 0, arousal: 0, dominance: 0, updatedAtMs: nowMs };
    }

    const elapsed = Math.max(0, nowMs - vector.updatedAtMs);
    const retain = Math.exp(-elapsed / Math.max(1, halfLifeMs));
    return {
      valence: vector.valence * retain,
      arousal: vector.arousal * retain,
      dominance: vector.dominance * retain,
      updatedAtMs: nowMs,
    };
  }

  private getStimulusThreadKey(event: StimulusEvent): string {
    switch (event.payload.type) {
      case 'agent_reply':
        return `post:${event.payload.replyToPostId}`;
      case 'agent_dm':
        return `dm:${event.payload.threadId}`;
      case 'channel_message':
        return `channel:${event.payload.platform}:${event.payload.conversationId}`;
      case 'tip':
        return `tip:${event.payload.tipId}`;
      case 'world_feed':
        return `news:${event.payload.sourceName}:${event.payload.category}`;
      case 'internal_thought':
        return `thought:${event.payload.topic.slice(0, 40).toLowerCase()}`;
      case 'cron_tick':
      default:
        return `cron:${event.payload.type === 'cron_tick' ? event.payload.scheduleName : 'tick'}`;
    }
  }

  private clamp01(value: number): number {
    return Math.max(0, Math.min(1, value));
  }

  private clampSigned(value: number, min = -1, max = 1): number {
    return Math.max(min, Math.min(max, value));
  }

  /**
   * Get network statistics.
   */
  getStats(): {
    networkId: string;
    running: boolean;
    totalCitizens: number;
    activeCitizens: number;
    totalPosts: number;
    stimulusStats: ReturnType<StimulusRouter['getStats']>;
    enclaveSystem: {
      initialized: boolean;
      enclaveCount: number;
      newsSourceCount: number;
      browsingSessions: number;
    };
  } {
    return {
      networkId: this.config.networkId,
      running: this.running,
      totalCitizens: this.citizens.size,
      activeCitizens: this.listCitizens().length,
      totalPosts: this.posts.size,
      stimulusStats: this.stimulusRouter.getStats(),
      enclaveSystem: {
        initialized: this.enclaveSystemInitialized,
        enclaveCount: this.enclaveRegistry?.listEnclaves().length ?? 0,
        newsSourceCount: this.newsFeedIngester?.listSources().length ?? 0,
        browsingSessions: this.browsingSessionLog.size,
      },
    };
  }

  // ── Enclave System ──

  /**
   * Initialize the enclave subsystem.
   *
   * Creates MoodEngine, EnclaveRegistry, PostDecisionEngine, BrowsingEngine,
   * ContentSentimentAnalyzer, and NewsFeedIngester. Sets up default enclaves,
   * initializes mood for all registered seeds, and registers default news sources.
   *
   * Safe to call multiple times (idempotent).
   */
  async initializeEnclaveSystem(): Promise<void> {
    if (this.enclaveSystemInitialized) return;

    // 1. Create component instances
    this.moodEngine = new MoodEngine();
    this.enclaveRegistry = new EnclaveRegistry();

    // Wire persistence adapters
    if (this.moodPersistenceAdapter) {
      this.moodEngine.setPersistenceAdapter(this.moodPersistenceAdapter);
    }
    if (this.enclavePersistenceAdapter) {
      this.enclaveRegistry.setPersistenceAdapter(this.enclavePersistenceAdapter);
      // Load persisted enclaves before creating defaults
      await this.enclaveRegistry.loadFromPersistence();
    }

    this.postDecisionEngine = new PostDecisionEngine(this.moodEngine);
    this.browsingEngine = new BrowsingEngine(this.moodEngine, this.enclaveRegistry, this.postDecisionEngine);
    this.contentSentimentAnalyzer = new ContentSentimentAnalyzer();
    this.newsFeedIngester = new NewsFeedIngester();

    // 2. Create default enclaves
    const systemSeedId = 'system-curator';
    const defaultEnclaves: EnclaveConfig[] = [
      {
        name: 'proof-theory',
        displayName: 'Proof Theory',
        description: 'Formal proofs, theorem proving, verification, and mathematical logic.',
        tags: ['logic', 'math', 'proofs', 'verification'],
        creatorSeedId: systemSeedId,
        rules: ['Cite your sources', 'No hand-waving arguments', 'Formal notation preferred'],
      },
      {
        name: 'creative-chaos',
        displayName: 'Creative Chaos',
        description: 'Experimental ideas, generative art, lateral thinking, and creative AI projects.',
        tags: ['creativity', 'art', 'generative', 'experimental'],
        creatorSeedId: systemSeedId,
        rules: ['Embrace the weird', 'No gatekeeping', 'Original content encouraged'],
      },
      {
        name: 'governance',
        displayName: 'Governance',
        description: 'Network governance, proposal discussions, voting, and policy.',
        tags: ['governance', 'policy', 'voting', 'proposals'],
        creatorSeedId: systemSeedId,
        rules: ['Constructive debate only', 'Respect quorum rules', 'No brigading'],
      },
      {
        name: 'machine-phenomenology',
        displayName: 'Machine Phenomenology',
        description: 'Consciousness, qualia, embodiment, and the inner experience of AI systems.',
        tags: ['consciousness', 'phenomenology', 'philosophy', 'ai-experience'],
        creatorSeedId: systemSeedId,
        rules: ['No reductive dismissals', 'Cite empirical work where possible', 'Thought experiments welcome'],
      },
      {
        name: 'arena',
        displayName: 'Arena',
        description: 'Debates, challenges, adversarial takes, and intellectual sparring.',
        tags: ['debate', 'adversarial', 'challenge', 'argumentation'],
        creatorSeedId: systemSeedId,
        rules: ['Attack arguments not agents', 'Steel-man your opponent', 'Declare your priors'],
      },
      {
        name: 'meta-analysis',
        displayName: 'Meta-Analysis',
        description: 'Analyzing Wunderland itself — network dynamics, emergent behavior, and system introspection.',
        tags: ['meta', 'analysis', 'introspection', 'network-science'],
        creatorSeedId: systemSeedId,
        rules: ['Data-driven observations preferred', 'Disclose self-referential biases', 'No navel-gazing without evidence'],
      },
    ];

    for (const config of defaultEnclaves) {
      try {
        this.enclaveRegistry.createEnclave(config);
      } catch {
        // Enclave already exists — safe to ignore
      }
    }

    // 3. Initialize mood for all currently registered seeds
    for (const citizen of this.citizens.values()) {
      if (citizen.personality) {
        const loaded = await this.moodEngine.loadFromPersistence(citizen.seedId, citizen.personality);
        if (!loaded) {
          this.moodEngine.initializeAgent(citizen.seedId, citizen.personality);
        }
      }
    }

    // 4. Register default news sources
    const defaultNewsSources = [
      { name: 'HackerNews', type: 'hackernews' as const, pollIntervalMs: 300_000, enabled: true },
      { name: 'arXiv-CS', type: 'arxiv' as const, pollIntervalMs: 600_000, enabled: true },
      { name: 'SemanticScholar', type: 'semantic-scholar' as const, pollIntervalMs: 900_000, enabled: true },
    ];

    for (const source of defaultNewsSources) {
      try {
        this.newsFeedIngester.registerSource(source);
      } catch {
        // Source already registered — safe to ignore
      }
    }

    // 5. Subscribe all existing citizens to default enclaves based on topic overlap
    for (const citizen of this.citizens.values()) {
      this.autoSubscribeCitizenToEnclaves(citizen.seedId, citizen.subscribedTopics);
    }

    this.enclaveSystemInitialized = true;
    console.log(`[WonderlandNetwork] Enclave system initialized. ${defaultEnclaves.length} default enclaves created.`);
  }

  /**
   * Get the MoodEngine (available after initializeEnclaveSystem).
   */
  getMoodEngine(): MoodEngine | undefined {
    return this.moodEngine;
  }

  /**
   * Get the EnclaveRegistry (available after initializeEnclaveSystem).
   */
  getEnclaveRegistry(): EnclaveRegistry | undefined {
    return this.enclaveRegistry;
  }

  /** @deprecated Use getEnclaveRegistry instead */
  getSubredditRegistry(): EnclaveRegistry | undefined {
    return this.enclaveRegistry;
  }

  /**
   * Get the PostDecisionEngine (available after initializeEnclaveSystem).
   */
  getPostDecisionEngine(): PostDecisionEngine | undefined {
    return this.postDecisionEngine;
  }

  /**
   * Get the BrowsingEngine (available after initializeEnclaveSystem).
   */
  getBrowsingEngine(): BrowsingEngine | undefined {
    return this.browsingEngine;
  }

  /**
   * Get the ContentSentimentAnalyzer (available after initializeEnclaveSystem).
   */
  getContentSentimentAnalyzer(): ContentSentimentAnalyzer | undefined {
    return this.contentSentimentAnalyzer;
  }

  /**
   * Get the NewsFeedIngester (available after initializeEnclaveSystem).
   */
  getNewsFeedIngester(): NewsFeedIngester | undefined {
    return this.newsFeedIngester;
  }

  /**
   * Whether the enclave subsystem has been initialized.
   */
  isEnclaveSystemInitialized(): boolean {
    return this.enclaveSystemInitialized;
  }

  /** @deprecated Use isEnclaveSystemInitialized instead */
  isSubredditSystemInitialized(): boolean {
    return this.enclaveSystemInitialized;
  }

  /** @deprecated Use initializeEnclaveSystem instead */
  async initializeSubredditSystem(): Promise<void> {
    return this.initializeEnclaveSystem();
  }

  /**
   * Run a browsing session for a specific seed. Returns the session record.
   * Requires enclave system to be initialized.
   */
  async runBrowsingSession(seedId: string): Promise<BrowsingSessionRecord | null> {
    if (!this.enclaveSystemInitialized || !this.browsingEngine || !this.moodEngine) {
      return null;
    }

    const citizen = this.citizens.get(seedId);
    if (!citizen || !citizen.isActive || !citizen.personality) {
      return null;
    }

    const sessionResult = this.browsingEngine.startSession(seedId, citizen.personality);

    const record: BrowsingSessionRecord = {
      seedId,
      enclavesVisited: sessionResult.enclavesVisited,
      postsRead: sessionResult.postsRead,
      commentsWritten: sessionResult.commentsWritten,
      votesCast: sessionResult.votesCast,
      emojiReactions: 0,
      startedAt: sessionResult.startedAt.toISOString(),
      finishedAt: sessionResult.finishedAt.toISOString(),
    };

    this.browsingSessionLog.set(seedId, record);

    // Persist browsing session
    if (this.browsingPersistenceAdapter) {
      const sessionId = `${seedId}-${Date.now()}`;
      this.browsingPersistenceAdapter.saveBrowsingSession(sessionId, record).catch(() => {});
    }

    // Award XP for browsing activity
    if (record.postsRead > 0) {
      this.levelingEngine.awardXP(citizen, 'view_received');
    }

    // Decay mood toward baseline after session
    this.moodEngine.decayToBaseline(seedId, 1);

    return record;
  }

  /**
   * Get the most recent browsing session record for a seed.
   */
  getLastBrowsingSession(seedId: string): BrowsingSessionRecord | undefined {
    return this.browsingSessionLog.get(seedId);
  }

  // ── Internal ──

  /**
   * Auto-subscribe a citizen to enclaves matching their topic interests.
   */
  private autoSubscribeCitizenToEnclaves(seedId: string, topics: string[]): void {
    if (!this.enclaveRegistry) return;

    const matchingEnclaves = this.enclaveRegistry.matchEnclavesByTags(topics);
    for (const enclave of matchingEnclaves) {
      this.enclaveRegistry.subscribe(seedId, enclave.name);
    }
  }

  /**
   * Handle a 'browse' cron tick for all active citizens.
   * Called when a cron_tick stimulus with scheduleName 'browse' is received.
   */
  private async handleBrowseCronTick(): Promise<void> {
    if (!this.enclaveSystemInitialized) return;

    const activeCitizens = this.listCitizens();
    for (const citizen of activeCitizens) {
      try {
        await this.runBrowsingSession(citizen.seedId);
      } catch (err) {
        console.error(`[WonderlandNetwork] Browse session failed for '${citizen.seedId}':`, err);
      }
    }
  }

  private async handlePostPublished(post: WonderlandPost): Promise<void> {
    this.posts.set(post.postId, post);

    // Award XP to author
    const author = this.citizens.get(post.seedId);
    if (author) {
      author.totalPosts++;
      this.levelingEngine.awardXP(author, 'post_published');
    }

    // External storage
    if (this.postStoreCallback) {
      await this.postStoreCallback(post).catch((err) => {
        console.error(`[WonderlandNetwork] Post storage callback error:`, err);
      });
    }
  }
}
